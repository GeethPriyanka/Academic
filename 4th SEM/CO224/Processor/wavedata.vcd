$date
	Tue Sep 05 14:52:01 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module processor $end
$var wire 8 ! twosComplement [7:0] $end
$var wire 8 " mux2_out [7:0] $end
$var wire 1 # mux2 $end
$var wire 8 $ mux1_out [7:0] $end
$var wire 1 % mux1 $end
$var wire 3 & alu_select [2:0] $end
$var wire 32 ' Read_addr [31:0] $end
$var wire 8 ( RESULT [7:0] $end
$var wire 3 ) OUT2addr [2:0] $end
$var wire 8 * OUT2 [7:0] $end
$var wire 3 + OUT1addr [2:0] $end
$var wire 8 , OUT1 [7:0] $end
$var wire 8 - OPCODE [7:0] $end
$var wire 32 . Instruction [31:0] $end
$var wire 8 / Immediate [7:0] $end
$var wire 3 0 INaddr [2:0] $end
$var reg 1 1 clk $end
$var reg 1 2 reset $end
$var reg 1 3 reset_reg $end
$scope module alu $end
$var wire 3 4 Select [2:0] $end
$var wire 8 5 DATA2 [7:0] $end
$var wire 8 6 DATA1 [7:0] $end
$var reg 8 7 Result [7:0] $end
$upscope $end
$scope module cu $end
$var wire 8 8 opcode [7:0] $end
$var wire 3 9 alu_select [2:0] $end
$var reg 1 % mux1 $end
$var reg 1 # mux2 $end
$upscope $end
$scope module ins_mem $end
$var wire 32 : Read_addr [31:0] $end
$var reg 32 ; Instruction [31:0] $end
$upscope $end
$scope module ins_reg $end
$var wire 32 < Instruction [31:0] $end
$var wire 1 1 clk $end
$var wire 3 = OUT2addr [2:0] $end
$var wire 3 > OUT1addr [2:0] $end
$var wire 8 ? OPCODE [7:0] $end
$var wire 8 @ Immediate [7:0] $end
$var wire 3 A INaddr [2:0] $end
$upscope $end
$scope module m1 $end
$var wire 8 B IN1 [7:0] $end
$var wire 1 % SELECT $end
$var wire 8 C OUT [7:0] $end
$var wire 8 D IN2 [7:0] $end
$upscope $end
$scope module m2 $end
$var wire 1 # SELECT $end
$var wire 8 E OUT [7:0] $end
$var wire 8 F IN2 [7:0] $end
$var wire 8 G IN1 [7:0] $end
$upscope $end
$scope module pc $end
$var wire 1 2 RESET $end
$var wire 1 1 clk $end
$var reg 32 H Read_addr [31:0] $end
$upscope $end
$scope module regf $end
$var wire 8 I IN [7:0] $end
$var wire 3 J INaddr [2:0] $end
$var wire 3 K OUT1addr [2:0] $end
$var wire 3 L OUT2addr [2:0] $end
$var wire 1 3 RESET $end
$var wire 1 1 clk $end
$var reg 8 M OUT1 [7:0] $end
$var reg 8 N OUT2 [7:0] $end
$var integer 32 O i [31:0] $end
$upscope $end
$scope module t_cmp $end
$var wire 8 P IN [7:0] $end
$var wire 8 Q COMPLIMENT [7:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx Q
bx P
b1000 O
bx N
bx M
b0 L
b111 K
b100 J
b11111111 I
b0 H
bx G
bx F
bx E
bx D
b11111111 C
b11111111 B
b100 A
b11111111 @
b1000 ?
b111 >
b0 =
b1000000001000000000011111111 <
b1000000001000000000011111111 ;
b0 :
b0 9
b1000 8
b11111111 7
b11111111 6
bx 5
b0 4
03
02
01
b100 0
b11111111 /
b1000000001000000000011111111 .
b1000 -
bx ,
b111 +
bx *
b0 )
b11111111 (
b0 '
b0 &
0%
b11111111 $
x#
bx "
bx !
$end
#10
b0 "
b0 D
b0 E
b0 *
b0 5
b0 N
b0 !
b0 F
b0 Q
b0 ,
b0 G
b0 M
b0 P
11
#20
b10101010 (
b10101010 7
b10101010 I
b10101010 $
b10101010 6
b10101010 C
b10 +
b10 >
b10 K
b110 0
b110 A
b110 J
b10101010 /
b10101010 @
b10101010 B
b1000000001100000000010101010 .
b1000000001100000000010101010 ;
b1000000001100000000010101010 <
b1 '
b1 :
b1 H
01
#30
11
#40
b10111011 (
b10111011 7
b10111011 I
b10111011 $
b10111011 6
b10111011 C
b11 +
b11 >
b11 K
b11 0
b11 A
b11 J
b10111011 /
b10111011 @
b10111011 B
b1000000000110000000010111011 .
b1000000000110000000010111011 ;
b1000000000110000000010111011 <
b10 '
b10 :
b10 H
01
#50
11
#60
b0 (
b0 7
b0 I
b0 $
b0 6
b0 C
b1 &
b1 4
b1 9
0#
1%
b110 )
b110 =
b110 L
b101 0
b101 A
b101 J
b11 /
b11 @
b11 B
b1 -
b1 8
b1 ?
b1000001010000011000000011 .
b1000001010000011000000011 ;
b1000001010000011000000011 <
b11 '
b11 :
b11 H
01
#70
b10111011 $
b10111011 6
b10111011 C
b1100101 (
b1100101 7
b1100101 I
b10111011 "
b10111011 D
b10111011 E
b10101010 *
b10101010 5
b10101010 N
b1000101 !
b1000101 F
b1000101 Q
b10111011 ,
b10111011 G
b10111011 M
b10111011 P
11
#80
b10101010 (
b10101010 7
b10101010 I
b10 &
b10 4
b10 9
b101 +
b101 >
b101 K
b100 )
b100 =
b100 L
b1 0
b1 A
b1 J
b101 /
b101 @
b101 B
b10 -
b10 8
b10 ?
b10000000010000010000000101 .
b10000000010000010000000101 ;
b10000000010000010000000101 <
b100 '
b100 :
b100 H
01
#90
b1100101 $
b1100101 6
b1100101 C
b1100101 (
b1100101 7
b1100101 I
b1100101 "
b1100101 D
b1100101 E
b11111111 *
b11111111 5
b11111111 N
b10011011 !
b10011011 F
b10011011 Q
b1100101 ,
b1100101 G
b1100101 M
b1100101 P
11
#100
b11111111 (
b11111111 7
b11111111 I
b11 &
b11 4
b11 9
b110 +
b110 >
b110 K
b1 )
b1 =
b1 L
b10 0
b10 A
b10 J
b110 /
b110 @
b110 B
b11 -
b11 8
b11 ?
b11000000100000000100000110 .
b11000000100000000100000110 ;
b11000000100000000100000110 <
b101 '
b101 :
b101 H
01
#110
b10101010 $
b10101010 6
b10101010 C
b11101111 (
b11101111 7
b11101111 I
b10101010 "
b10101010 D
b10101010 E
b1100101 *
b1100101 5
b1100101 N
b1010110 !
b1010110 F
b1010110 Q
b10101010 ,
b10101010 G
b10101010 M
b10101010 P
11
#120
b10101010 (
b10101010 7
b10101010 I
b0 &
b0 4
b0 9
b10 +
b10 >
b10 K
b0 )
b0 =
b0 L
b111 0
b111 A
b111 J
b10 /
b10 @
b10 B
b0 -
b0 8
b0 ?
b1110000000000000010 .
b1110000000000000010 ;
b1110000000000000010 <
b110 '
b110 :
b110 H
01
#130
b11101111 (
b11101111 7
b11101111 I
b11101111 $
b11101111 6
b11101111 C
b11101111 "
b11101111 D
b11101111 E
b0 *
b0 5
b0 N
b10001 !
b10001 F
b10001 Q
b11101111 ,
b11101111 G
b11101111 M
b11101111 P
11
#140
b10001 (
b10001 7
b10001 I
b10001 $
b10001 6
b10001 C
b10001 "
b10001 D
b10001 E
b1 &
b1 4
b1 9
1#
b11 +
b11 >
b11 K
b111 )
b111 =
b111 L
b100 0
b100 A
b100 J
b11 /
b11 @
b11 B
b1001 -
b1001 8
b1001 ?
b1001000001000000011100000011 .
b1001000001000000011100000011 ;
b1001000001000000011100000011 <
b111 '
b111 :
b111 H
01
#150
b1000101 $
b1000101 6
b1000101 C
b110100 (
b110100 7
b110100 I
b1000101 "
b1000101 D
b1000101 E
b11101111 *
b11101111 5
b11101111 N
b1000101 !
b1000101 F
b1000101 Q
b10111011 ,
b10111011 G
b10111011 M
b10111011 P
11
#160
b1000 '
b1000 :
b1000 H
01
